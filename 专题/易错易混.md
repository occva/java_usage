
## `final` 和 `static` 的区别

| 特性       | `final`         | `static`     |
| -------- | --------------- | ------------ |
| **修饰对象** | 类、方法、变量         | 变量、方法        |
| **含义**   | 最终的、不可变的        | 静态的、属于类本身    |
| **类**    | 不能被继承           | -            |
| **方法**   | 不能被覆盖           | 可以被调用，但不能被覆盖 |
| **变量**   | 值不能被改变          | 属于类，所有实例共享   |
| **调用方式** | 通过实例调用          | 通过类名调用       |
| **初始化**  | 必须在声明时或构造方法中初始化 | 在类加载时初始化     |


**final 和 static 可以同时修饰一个变量吗？**
- 可以。`final static` 修饰的变量是一个常量，属于类本身，所有实例共享。
- 示例：
```java
  class Constants {
      final static int MAX_VALUE = 100;
  }
```


**`final` 和 `static` 可以同时修饰一个方法吗？**

- **可以。** `final static` 修饰的方法是静态的，且不能被覆盖。
  
- **示例：**

``` java
class MathUtils {
    final static int add(int a, int b) {
        return a + b;
    }
}
```



**`final` 和 `static` 的区别是什么？**

- **`final`：** 表示不可变，用于修饰类、方法和变量，确保它们的定义或值不会被改变。
    
- **`static`：** 表示静态，用于修饰变量和方法，表示它们属于类本身，而不是类的某个实例。
    

**为什么 `final` 方法不能被覆盖？**

- `final` 方法不能被覆盖是为了确保子类不会改变父类方法的实现逻辑，保证父类方法的行为一致性。
    

**为什么 `static` 方法不能被覆盖？**

- `static` 方法属于类，而不是类的实例。覆盖（重写）是基于实例的多态特性，而 `static` 方法不依赖于实例，因此不能被覆盖。不过，`static` 方法可以被隐藏（通过子类定义同名方法）。
    

**`final` 和 `static` 的最佳实践是什么？**

- **`final`：** 用于定义不可变的类、方法和常量，提高代码的安全性和可读性。
    
- **`static`：** 用于定义类级别的变量和方法，减少实例之间的重复，提高效率。




 语法区别 
 1. **构造器**：抽象类能有构造器，接口不能有。 
 2. **成员变量** - 抽象类：有普通成员变量。 - 接口：无普通成员变量，定义的变量是 `public static final` 类型。 
 3. **方法** - 抽象类：可包含非抽象的普通方法，抽象方法访问类型可以是 `public`、`protected` 和默认访问权限。 - 接口：Java 8 前所有方法必须是抽象的，且只能是 `public`；Java 8 起可拥有默认方法（`default` 修饰）和类方法（`static` 修饰），Java 9 允许有 `private` 方法，后三者需有方法体。 
 4. **继承与实现**：一个类能实现多个接口，但只能继承一个抽象类。 
 5. 应用区别 
 - **接口**：主要在系统架构设计中起作用，体现一种规范。
 - **抽象类**：在代码实现方面发挥作用，可实现代码重用，如模板模式。



## &、&&、|、|| 运算符对比


### 优先级对比

#### 按位运算符 vs 逻辑运算符

按位运算符（&、|）的优先级高于逻辑运算符（&&、||）。这意味着在表达式中，按位运算会先于逻辑运算进行计算。

#### 逻辑运算符优先级顺序

逻辑运算符的优先级顺序为：! > && > ||。也就是说，逻辑非（!）的优先级最高，其次是逻辑与（&&），最后是逻辑或（||）。
### 短路行为差异

#### && 和 ||

具有短路行为。当左侧操作数为假时，&&会跳过右侧操作数的评估；当左侧操作数为真时，||会跳过右侧操作数的评估。

#### & 和 |

不具有短路行为。无论左侧操作数的值如何，右侧操作数总是会被评估。



### == 和 equals 的区别是什么？

类型不同。== 是java中的一个运算符，而equals是定义在Object类中的一个方法，可以被所有类继承和重写，用以实现特定的比较逻辑

1、equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。

2、== ：用于比较引用和比较基本数据类型时具有不同的功能，具体如下：

（1）、基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。

（2）、引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。


## **启动一个线程是用 run()还是 start()?**

启动一个线程是调用 start()方法，使线程进入就绪状态，以后可以被调度为运行状态。
run()方法是线程的线程执行体——也就是线程将要完成的事情。

## **多线程有几种实现方法?同步有几种实现方法?**

在 Java5 以前，有如下两种：
第一种：继承 Thread 类，重写它的 run()方法。
第二种：实现 Runnable 接口，并重写它的 run()方法
从 Java 5 开始，Java 提供了第三种方式来创建多线程：实现 Callable 接口，并实现 call()
方法。Callable 接口相当于 Runnable 接口的增强版，因为 Callable 接口中定义的 call()方法
既拥有返回值，也可以声明抛出异常。


## **sleep()和 wait()有什么区别?**

sleep()是 Thread 类的静态方法，它的作用是让当前线程从运行状态转入阻塞状态，线程
执行暂停下来，当一个线程通过 sleep()方法暂停之后，该线程并不会释放它对同步监视器的
加锁。
wait()是 Object 对象的方法，但实际上只有同步监视器才能调用该方法。当程序在同步
代码块、或同步方法内通过同步监视器调用该方法时，将会导致当前线程释放对该同步监视
器的加锁，而该线程则会进入该同步监视器的等待池中，直到该同步监视器调用 notify()或
notifyAll()来通知该线程。

## **error 和 exception 有什么区别?**

Error 错误，一般是指虚拟机相关的问题，如系统崩溃、虚拟机出错误、动态链接失败
等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错
误，因此应用程序不应该试图使用 catch 块来捕获 Error 对象。
由于编译器会对 Error 进行检查，不会强制要求程序员必须处理 Error，因此 Error 也被
归入 unchecked 异常分类中（另外：运行时异常也属于 unchecked 异常）。
Exception 表示一种设计或实现问题。也就是说，程序员应该对这些情况进行考虑、并
提供相应的处理。

## 是否可以继承 String 类?

String 类是 final 类，不可以被继承。




## 重载和重写什么区别？
重载（Overload）和重写（Override）是 Java 中两个非常基础但常被混淆的概念，它们都涉及方法的定义与使用，但含义和目的完全不同：

---

### ✅ 一、重载（Overload）

**发生位置**：**同一个类中**

**含义**：**方法名相同，但参数列表不同**

#### 特点：

|特点|说明|
|---|---|
|方法名相同|是必须的|
|参数列表不同|必须不同（参数个数或类型）|
|返回值可以不同|但不能仅通过返回值来区分|
|访问修饰符可以不同|没有限制|
|和继承无关|是编译期行为|

#### 示例：

```java
public class Example {
    void print(String msg) {
        System.out.println(msg);
    }

    void print(String msg, int times) {
        for (int i = 0; i < times; i++) {
            System.out.println(msg);
        }
    }
}
```

---

### ✅ 二、重写（Override）

**发生位置**：**子类中**

**含义**：**子类重新定义父类的方法（实现替换）**

#### 特点：

|特点|说明|
|---|---|
|方法名、参数列表完全一致|必须相同|
|返回值可以是父类返回值的子类型（协变返回类型）||
|访问修饰符不能更严格|例如父类是 `public`，子类不能是 `protected`|
|必须在继承体系中|否则不算重写|
|可加 `@Override` 注解|编译器辅助检查|

#### 示例：

```java
class Animal {
    void speak() {
        System.out.println("Animal speaks");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Dog barks");
    }
}
```

---

### 🔍 总结对比

|对比项|重载（Overload）|重写（Override）|
|---|---|---|
|是否跨类|否，同类中|是，父类和子类之间|
|参数列表|必须不同|必须相同|
|返回值|可不同，但不能仅靠它区分|可以是子类类型（协变）|
|修饰符|无限制|不能比父类更严格|
|编译期/运行期|编译时决定调用哪个方法|运行时动态绑定|

---
##  throw和throws

`throw` 和 `throws` 是 Java 异常处理机制中两个容易混淆但完全不同的关键字，它们在用途、位置、作用上都有明显区别。

---

### ✅ 一、`throw`：**抛出异常对象**

- **作用**：真正“抛出”一个异常实例
    
- **位置**：**方法体内部**
    
- **格式**：`throw new 异常类型();`
    
- **只能抛出一个异常对象**
    

#### 示例：

```java
public void checkAge(int age) {
    if (age < 18) {
        throw new IllegalArgumentException("未成年人禁止入内");
    }
}
```

---

### ✅ 二、`throws`：**声明异常可能被抛出**

- **作用**：用于方法签名中，**声明该方法可能抛出某些异常**
    
- **位置**：**方法声明处**
    
- **格式**：`方法名(...) throws 异常类型1, 异常类型2`
    

#### 示例：

```java
public void readFile(String path) throws IOException {
    FileReader reader = new FileReader(path);
}
```

---

### 🔍 三、核心区别对比

|比较项|`throw`|`throws`|
|---|---|---|
|用途|主动抛出异常对象|声明方法可能抛出哪些异常|
|出现位置|方法体内部|方法声明后|
|后面接的内容|一个具体的异常对象（实例）|一个或多个异常类型（类）|
|关键词语义|动作：抛出异常|描述：声明异常|
|运行时/编译期|通常与实际抛出配合|影响调用者是否必须处理（捕获或继续抛出）|

---

### ✅ 四、结合使用示例

```java
public void process() throws IOException {
    throw new IOException("文件读取失败");
}
```

---

### 🚨 注意事项

- `throw` 抛出的必须是 `Throwable` 的子类对象（一般是 `Exception` 或 `Error`）。
    
- 如果方法使用了 `throws` 抛出**受检异常**（如 `IOException`），调用者**必须处理**（try-catch 或继续 throws）。
    
- **运行时异常（如 `NullPointerException`）即使不声明 throws，也可以 throw。**
    

---

## [深拷贝、浅拷贝是什么？](https://javabetter.cn/interview/java-34.html#_32-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%98%AF%E4%BB%80%E4%B9%88)

- 浅拷贝并不是真的拷贝，只是**复制指向某个对象的指针**，而不复制对象本身，新旧对象还是共享同一块内存。
- 深拷贝会另外**创造一个一模一样的对象**，新对象跟原对象不共享内存，修改新对象不会改到原对象。

## 什么是反射？
反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法

反射的优点
1.增加程序的灵活性，避免将程序写死到代码里
2.可以在程序运行的过程中，操作这些对象
3.测试时可以利用反射API访问类的私有成员，以保证测试代码覆盖率