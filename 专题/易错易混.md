
## `final` 和 `static` 的区别

| 特性       | `final`         | `static`     |
| -------- | --------------- | ------------ |
| **修饰对象** | 类、方法、变量         | 变量、方法        |
| **含义**   | 最终的、不可变的        | 静态的、属于类本身    |
| **类**    | 不能被继承           | -            |
| **方法**   | 不能被覆盖           | 可以被调用，但不能被覆盖 |
| **变量**   | 值不能被改变          | 属于类，所有实例共享   |
| **调用方式** | 通过实例调用          | 通过类名调用       |
| **初始化**  | 必须在声明时或构造方法中初始化 | 在类加载时初始化     |


**final 和 static 可以同时修饰一个变量吗？**
- 可以。`final static` 修饰的变量是一个常量，属于类本身，所有实例共享。
- 示例：
```java
  class Constants {
      final static int MAX_VALUE = 100;
  }
```


**`final` 和 `static` 可以同时修饰一个方法吗？**

- **可以。** `final static` 修饰的方法是静态的，且不能被覆盖。
  
- **示例：**

``` java
class MathUtils {
    final static int add(int a, int b) {
        return a + b;
    }
}
```



**`final` 和 `static` 的区别是什么？**

- **`final`：** 表示不可变，用于修饰类、方法和变量，确保它们的定义或值不会被改变。
    
- **`static`：** 表示静态，用于修饰变量和方法，表示它们属于类本身，而不是类的某个实例。
    

**为什么 `final` 方法不能被覆盖？**

- `final` 方法不能被覆盖是为了确保子类不会改变父类方法的实现逻辑，保证父类方法的行为一致性。
    

**为什么 `static` 方法不能被覆盖？**

- `static` 方法属于类，而不是类的实例。覆盖（重写）是基于实例的多态特性，而 `static` 方法不依赖于实例，因此不能被覆盖。不过，`static` 方法可以被隐藏（通过子类定义同名方法）。
    

**`final` 和 `static` 的最佳实践是什么？**

- **`final`：** 用于定义不可变的类、方法和常量，提高代码的安全性和可读性。
    
- **`static`：** 用于定义类级别的变量和方法，减少实例之间的重复，提高效率。




 语法区别 
 1. **构造器**：抽象类能有构造器，接口不能有。 
 2. **成员变量** - 抽象类：有普通成员变量。 - 接口：无普通成员变量，定义的变量是 `public static final` 类型。 
 3. **方法** - 抽象类：可包含非抽象的普通方法，抽象方法访问类型可以是 `public`、`protected` 和默认访问权限。 - 接口：Java 8 前所有方法必须是抽象的，且只能是 `public`；Java 8 起可拥有默认方法（`default` 修饰）和类方法（`static` 修饰），Java 9 允许有 `private` 方法，后三者需有方法体。 
 4. **继承与实现**：一个类能实现多个接口，但只能继承一个抽象类。 
 5. 应用区别 
 - **接口**：主要在系统架构设计中起作用，体现一种规范。
 - **抽象类**：在代码实现方面发挥作用，可实现代码重用，如模板模式。



## &、&&、|、|| 运算符对比


### 优先级对比

#### 按位运算符 vs 逻辑运算符

按位运算符（&、|）的优先级高于逻辑运算符（&&、||）。这意味着在表达式中，按位运算会先于逻辑运算进行计算。

#### 逻辑运算符优先级顺序

逻辑运算符的优先级顺序为：! > && > ||。也就是说，逻辑非（!）的优先级最高，其次是逻辑与（&&），最后是逻辑或（||）。
### 短路行为差异

#### && 和 ||

具有短路行为。当左侧操作数为假时，&&会跳过右侧操作数的评估；当左侧操作数为真时，||会跳过右侧操作数的评估。

#### & 和 |

不具有短路行为。无论左侧操作数的值如何，右侧操作数总是会被评估。



### == 和 equals 的区别是什么？

类型不同。== 是java中的一个运算符，而equals是定义在Object类中的一个方法，可以被所有类继承和重写，用以实现特定的比较逻辑

1、equals()：用来检测两个对象是否相等，即两个对象的内容是否相等。

2、== ：用于比较引用和比较基本数据类型时具有不同的功能，具体如下：

（1）、基础数据类型：比较的是他们的值是否相等，比如两个int类型的变量，比较的是变量的值是否一样。

（2）、引用数据类型：比较的是引用的地址是否相同，比如说新建了两个User对象，比较的是两个User的地址是否一样。


## **启动一个线程是用 run()还是 start()?**

启动一个线程是调用 start()方法，使线程进入就绪状态，以后可以被调度为运行状态。
run()方法是线程的线程执行体——也就是线程将要完成的事情。

## **多线程有几种实现方法?同步有几种实现方法?**

在 Java5 以前，有如下两种：
第一种：继承 Thread 类，重写它的 run()方法。
第二种：实现 Runnable 接口，并重写它的 run()方法
从 Java 5 开始，Java 提供了第三种方式来创建多线程：实现 Callable 接口，并实现 call()
方法。Callable 接口相当于 Runnable 接口的增强版，因为 Callable 接口中定义的 call()方法
既拥有返回值，也可以声明抛出异常。


## **sleep()和 wait()有什么区别?**

sleep()是 Thread 类的静态方法，它的作用是让当前线程从运行状态转入阻塞状态，线程
执行暂停下来，当一个线程通过 sleep()方法暂停之后，该线程并不会释放它对同步监视器的
加锁。
wait()是 Object 对象的方法，但实际上只有同步监视器才能调用该方法。当程序在同步
代码块、或同步方法内通过同步监视器调用该方法时，将会导致当前线程释放对该同步监视
器的加锁，而该线程则会进入该同步监视器的等待池中，直到该同步监视器调用 notify()或
notifyAll()来通知该线程。

## **error 和 exception 有什么区别?**

Error 错误，一般是指虚拟机相关的问题，如系统崩溃、虚拟机出错误、动态链接失败
等，这种错误无法恢复或不可能捕获，将导致应用程序中断。通常应用程序无法处理这些错
误，因此应用程序不应该试图使用 catch 块来捕获 Error 对象。
由于编译器会对 Error 进行检查，不会强制要求程序员必须处理 Error，因此 Error 也被
归入 unchecked 异常分类中（另外：运行时异常也属于 unchecked 异常）。
Exception 表示一种设计或实现问题。也就是说，程序员应该对这些情况进行考虑、并
提供相应的处理。

## 是否可以继承 String 类?

String 类是 final 类，不可以被继承。
