[美团Java暑期实习一面面经_牛客网](https://www.nowcoder.com/feed/main/detail/ef3d9641d17f4ce694d72460c207c1fa?sourceSSR=search)
### 1. 为什么用base62去生成短链接
Base62是一种编码方式，使用62个字符（0-9、a-z、A-Z）来表示数字。
字符集丰富，生成的短链接相对较短，占用空间小、**避免特殊字符**
### 2. 为什么想用到布隆过滤器
布隆过滤器是一种空间效率高的概率型数据结构，用于判断一个元素是否在一个集合中，用于**减少数据库或缓存的查询压力**,解决缓存穿透问题,
场景： 例如用户登录时，我们需要判断用户是否存在数据库中。如果直接查数据库，会有较高的 I/O 和查询开销。
优化方案：
1. 先使用布隆过滤器查询用户是否可能存在。
2. 如果布隆过滤器返回不存在，则直接拒绝请求（减少数据库查询）。
3. 如果布隆过滤器返回可能存在，再去查询数据库进行最终确认。


示例： 在短链服务（如短网址系统）中，判断短链是否已存在数据库中。
### 3. 项目做过性能调优吗
数据库调优（索引优化、SQL 语句优化等）、代码优化（减少不必要的计算、优化算法等）、缓存优化（合理设置缓存策略等）
### 4. 消息队列削峰
在高并发场景下，大量的请求可能会瞬间涌入系统，导致系统负载过高。消息队列可以将这些请求暂存起来，按照一定的速度处理，从而达到削峰的目的。
### 5. 为什么要保证消息只消费一次，重复消费会怎么样
在一些业务场景下，消息的重复消费可能会导致数据重复处理、业务逻辑混乱等问题。例如，订单消息重复消费可能导致订单重复支付。
解决办法：
- 设置消费者为自动确认模式，如果服务在确认前宕机，重启后可能会再次消费同一消息。
- 通过业务唯一标识检查数据库中数据是否存在，若不存在则处理消息，若存在则忽略，避免重复消费。
- 使用Redis分布式锁或数据库锁来确保操作的幂等性。





### 八股

### 1. OSI七层结构
 OSI模型分为七层，从下到上依次为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每一层都有其特定的功能，如物理层负责物理连接，传输层负责数据传输的可靠性等。
### 2. 4层协议
4层协议通常指的是TCP/IP协议栈中的四层，从下到上依次为链路层、网络层、传输层和应用层。TCP/IP协议栈是互联网的基础协议，每一层都有其核心协议，如网络层的IP协议、传输层的TCP和UDP协议等。
### 3. HTTPS的原理，加密的详细过程

	HTTPS是在HTTP的基础上，通过SSL/TLS协议实现加密传输的协议。其加密过程包括：
	- 证书交换：客户端与服务器通过SSL/TLS握手，交换数字证书，验证服务器的身份。 
	- 密钥协商：双方通过协商生成对称密钥，用于后续的数据加密。  
	- 数据加密传输：使用对称密钥对数据进行加密传输，保证数据的机密性和完整性。


### 4. TCP UDP
- **TCP**（传输控制协议）是一种面向连接的、可靠的传输层协议，提供数据的可靠传输，通过三次握手建立连接，四次挥手断开连接，适用于对可靠性要求较高的场景。
    
- **UDP**（用户数据报协议）是一种无连接的、不可靠的传输层协议，不保证数据的可靠传输，但传输速度快，适用于对实时性要求较高的场景。


### 5. 进程之间的通信方式  

    - 管道（Pipe）：包括匿名管道和命名管道，用于父子进程或相关进程之间的通信。
    - 消息队列：通过在内核中创建消息队列，进程可以向队列中写入或读取消息。
    - 共享内存：多个进程共享一块内存区域，通过内存进行数据交换。
    - 信号（Signal）：进程之间可以通过发送信号来通知对方某些事件的发生。

### 6. 线程之间的通信方式


    - **管道（Pipe）**：包括匿名管道和命名管道，用于父子进程或相关进程之间的通信。
    - **消息队列**：通过在内核中创建消息队列，进程可以向队列中写入或读取消息。
    - **共享内存**：多个进程共享一块内存区域，通过内存进行数据交换。
    - **信号（Signal）**：进程之间可以通过发送信号来通知对方某些事件的发生。


### 7. 进程的状态

就绪、运行、阻塞

### 8. 内存的分页分段

| 对比项      | 分页（Paging）         | 分段（Segmentation）     |
| -------- | ------------------ | -------------------- |
| **管理方式** | 物理划分               | 逻辑划分                 |
| **单位**   | 固定大小的页（Page）       | 变量大小的段（Segment）      |
| **地址结构** | 逻辑地址 = 页号 + 页内偏移量  | 逻辑地址 = 段号 + 段内偏移量    |
| **大小**   | 每一页大小固定（如4KB）      | 每个段大小可变              |
| **存储方式** | 各页可离散存放在物理内存       | 各段可离散存放在物理内存         |
| **外部碎片** | 无外部碎片，但有内部碎片       | 可能存在外部碎片             |
| **内部碎片** | 页大小固定，可能存在浪费       | 无内部碎片（按需分配）          |
| **适用场景** | 适用于操作系统的内存管理，如虚拟内存 | 适用于编译器或程序设计，如代码段、数据段 |

### 9. JVM的内存模型

**线程私有**的**程序计数器**、**java虚拟机栈**、**本地方法栈**
**线程共享**的**堆空间**、**方法区**、**运行时常量池**。

### 11. Java数据结构底层原理

- **ArrayList**：基于动态数组，默认容量10，扩容1.5倍。
- **LinkedList**：基于双向链表，增删快，查询慢。
- **HashMap**：数组 + 链表（JDK1.7）或数组 + 链表 + 红黑树（JDK1.8）。
- **ConcurrentHashMap**：分段锁（JDK1.7）或CAS + Synchronized + 红黑树（JDK1.8）。

### 10. JVM的垃圾回收

- **垃圾回收的区域**：
	  - 年轻代（Eden + Survivor1 + Survivor2）
	  - 老年代
	  - 元空间（Metaspace）

- **常见垃圾回收算法**：
	  - **引用计数（已淘汰）**：每个对象增加引用计数，计数为0时回收。
	  - **标记-清除**：标记存活对象，回收未标记对象，会产生碎片。
	  - **标记-整理**：标记存活对象并整理，使存活对象集中，提高分配效率。
	  - **复制算法**：用于年轻代，采用Eden + Survivor区，减少碎片。
	  - **分代回收**：年轻代（Minor GC，频繁，采用复制算法）、老年代（Major GC，标记清除/整理）、Full GC（全局回收，影响性能）。

- **常见垃圾回收器**：
	  - Serial（单线程）
	  - Parallel（多线程）
	  - CMS（低延迟）
	  - G1（区域化管理）
	  - ZGC（低延迟大堆）


### 12. concurrenthashmap怎么保证并发安全

- **JDK1.7**：
  - Segment分段锁：使用ReentrantLock对每个分段进行锁定，降低锁竞争。

- **JDK1.8**：
  - CAS + Synchronized：
    - 使用CAS（Compare-And-Swap）实现无锁操作，减少锁冲突。
    - 在链表或红黑树操作时，使用Synchronized保证并发安全。
    - 采用 `Node<K,V>[] table` 数组存储数据，扩容时采用 `forwardingNode` 机制避免数据丢失。


### 13. 数据结构线程安全

- **线程不安全的集合**：
  - ArrayList、HashMap、LinkedList、HashSet等。

- **线程安全的集合**：
  - Vector（同步方法，性能较低）
  - Collections.synchronizedXXX()（使用synchronized包装）
  - CopyOnWriteArrayList（写时复制，适用于读多写少）
  - ConcurrentHashMap（分段锁/CAS）
  - ConcurrentLinkedQueue（无锁队列，CAS操作）


### 14. MySql隔离级别

读未提交、读已提交、可重复读、串行化


### 15. 索引数据结构

- **B+树（MySQL索引结构）**：所有数据存储在叶子节点，非叶子节点仅存储索引，提高范围查询效率。
- **哈希索引（适用于等值查询，如Memory表）**。
- **全文索引（适用于文本搜索）**。
- **R-Tree（空间索引，适用于GIS）**。


### 16. synchronize是一种什么类型的锁 重入、打断

- **可重入锁**：同一线程可以多次获取锁，不会死锁。
- **非公平锁**：线程获取锁时，不一定是按照请求的顺序获取（JVM优化）。
- **不可中断锁**：线程进入 `synchronized` 代码块后无法中断，除非抛出异常或执行完成。

### 17. 什么注解用的比较多

### 18. 熟悉哪些第三方组件 netty熟不熟悉

- **熟悉的组件**：
  - Spring Boot、Spring Cloud（微服务架构）
  - MyBatis、Hibernate（ORM框架）
  - Redis、Kafka、RabbitMQ（缓存、消息队列）
  - Elasticsearch、MongoDB（大数据存储）
  - Docker、Kubernetes（容器化部署）

- **Netty熟悉吗？**
  - Netty是高性能NIO网络框架，适用于高并发网络编程。
  - 基于Reactor模式，提供EventLoopGroup进行事件驱动。
  - 采用 ChannelPipeline 处理数据流，支持自定义 Handler。


### 19. 为什么会有微服务，微服务有什么好处


- **为什么会有微服务？**
  - 传统单体架构在规模扩大后难以维护，部署更新复杂，影响稳定性。
  - 微服务架构将系统拆分成独立服务，每个服务可以独立开发、部署、扩展。

- **微服务的好处**：
  - **独立部署**：单个服务升级不影响整体系统。
  - **弹性扩展**：按需扩展，提高资源利用率。
  - **技术多样性**：不同微服务可使用不同技术栈。
  - **高可用**：单个服务故障不影响整个系统。


