
[我实习都还没投，提前批就开始了？？](https://mp.weixin.qq.com/s/j8UuyQBw6Clg0_BRMeWSZQ)
![](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZdegatV13zg1str3Nhp4lvXJ5cK2Wxox6wjVBTiaFA3NAXe1kt4HCBtqibbyUNWcuLJxvJNP4UlGp5w/640?wx_fmt=png&from=appmsg)

那话说回来，TP-Link 面试难度如何？

我看了很多同学的 TP-Link 面经，感觉相比互联网大厂难度是低一些的，一场面试平均是 30 分钟左右，而互联网公司普遍是一个小时，相当于比互联网公司面试强度少了 50%。

TP-Link  面试流程有三轮面试，前两轮会问技术多一些，第三轮更多是聊天局了。

我看了 TP-Link 校招的岗位，虽然大部分都是嵌入式，但是其实也有后端开发的岗位，主要是做管理设备类的后端系统，比如物联网后台系统等等。这次也给大家分享 2 个 TP-Link 的校招一面的面经：

*   Java 后端一面，你没看错，就问了四个问题，一开始同学以为是 KPI 面，没想到还是直接进入二面了
    
*   C++ 嵌入式一面，问的都很基础，就简单问了 C++、计算机网络、操作系统这三个方面的知识点
    

这两场面经虽然是没有算法的，但是并不代表 TP-Link 不会拷打算法，有些同学面试 TP-Link 还是会遇到手撕算法的，具体面试官会不会给你出算法题，就看缘分啦。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZdegatV13zg1str3Nhp4lvX6gF24BOryXsxr6rQcmeLsA85t0PAu3dkkl2P984LZPSc9R5vicKk1lQ/640?wx_fmt=png&from=appmsg)

TPLink 联洲（Java 后端一面）
--------------------

### 1. synchronize 关键字怎么用？

`synchronized` 关键字用于实现线程同步，从而保证在同一时刻只有一个线程能访问被 `synchronized` 修饰的代码块或者方法。

当一个线程进入`synchronized`代码块或方法时，它会获取关联对象的锁；当线程离开该代码块或方法时，锁会被释放。如果其他线程尝试获取同一个对象的锁，它们将被阻塞，直到锁被释放。

其中，syncronized 加锁时有无锁、偏向锁、轻量级锁和重量级锁几个级别。偏向锁用于当一个线程进入同步块时，如果没有任何其他线程竞争，就会使用偏向锁，以减少锁的开销。轻量级锁使用线程栈上的数据结构，避免了操作系统级别的锁。重量级锁则涉及操作系统级的互斥锁。

`synchronized`关键字可以用于方法或代码块：

*   **示例：synchronized 方法，**当使用 `synchronized` 修饰实例方法时，同一时刻仅允许一个线程访问该方法。此时，锁对象是调用该方法的实例对象。
    

```
public class Counter {  
    private int count = 0;  
  
    public synchronized void increment() {  
        count++;  
    }  
  
    public synchronized int getCount() {  
        return count;  
    }  
}  

```

*   **示例：synchronized 代码块，**可以使用 `synchronized` 关键字来修饰代码块，从而指定锁对象。
    

```
public class Counter {  
    private Object lock = new Object();  
    private int count = 0;  
  
    public void increment() {  
        synchronized (lock) {  
            count++;  
        }  
    }  
}  

```

### 2. redis 的常见的数据类型有哪些？

Redis 提供了丰富的数据类型，常见的有五种数据类型：**String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）**。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZdegatV13zg1str3Nhp4lvX9b3ZFxGTCz191T4Em9ibWiaiaVCfAicG6tgPNq3vPNLSkQia9iaqfCeBsicVg/640?wx_fmt=png&from=appmsg)![](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZdegatV13zg1str3Nhp4lvXicTgUCa3Kd2iaRicQPawhPTicpmk6PXncxozj3o7ZG6d5XzChibO8uXTWWg/640?wx_fmt=png&from=appmsg)

随着 Redis 版本的更新，后面又支持了四种数据类型：**BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）**。Redis 五种数据类型的应用场景：

*   String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
    
*   List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
    
*   Hash 类型：缓存对象、购物车等。
    
*   Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
    
*   Zset 类型：排序场景，比如排行榜、电话和姓名排序等。
    

Redis 后续版本又支持四种数据类型，它们的应用场景如下：

*   BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
    
*   HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
    
*   GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
    
*   Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。
    

### 3. MySQL 的隔离级别有哪些？

*   **读未提交（read uncommitted）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
    
*   **读提交（read committed）**，指一个事务提交之后，它做的变更才能被其他事务看到；
    
*   **可重复读（repeatable read）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
    
*   **串行化（serializable）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；
    

按隔离水平高低排序如下：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZdegatV13zg1str3Nhp4lvXIgFIPZaxhr2jEHzGcibtVUl8yShhQpicH5bIUGNianr0QaHTjSqml9adw/640?wx_fmt=png&from=appmsg)

针对不同的隔离级别，并发事务时可能发生的现象也会不同。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZdegatV13zg1str3Nhp4lvXxWcKzPgzkFHbV0oMcibRzdtTuFgqaJ1PnwvvYcq4lRHRsT0ibiasNu4DA/640?wx_fmt=png&from=appmsg)也就是说：

*   在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；
    
*   在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；
    
*   在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；
    
*   在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。
    

接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：

![](https://mmbiz.qpic.cn/sz_mmbiz_png/J0g14CUwaZdegatV13zg1str3Nhp4lvXBHa2NeOKnnAp90XQZxu6psNRNGZdMicV0fQKm9GffibtzXNVdia9ibyPBA/640?wx_fmt=png&from=appmsg)

在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：

*   在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；
    
*   在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；
    
*   在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；
    
*   在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200 万。
    

这四种隔离级别具体是如何实现的呢？

*   对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
    
*   对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
    
*   对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，**「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。
    

### 4. hashmap 和 concurrenthashmap 的区别是什么？

> JDK1.7 版本：hashmap 和 concurrenthashmap 的区别

*   内存结构：**hashmap** 采用数组 + 链表的结构。数组是 `HashMap` 的主体，链表则是为了解决哈希冲突而存在。当两个不同的键通过哈希函数计算出相同的数组索引时，它们会以链表的形式存储在该索引位置。`ConcurrentHashMap`采用分段锁机制，内部结构是一个 `Segment` 数组，每个 `Segment` 类似于一个小的 `HashMap`，它也有自己的数组和链表结构。
    
*   线程安全性：**hashmap** 是非线程安全的，在多线程环境下，如果多个线程同时对 `HashMap` 进行读写操作，可能会导致数据不一致、死循环等问题。`ConcurrentHashMap`是线程安全的。每个 `Segment` 都有自己的锁，不同的 `Segment` 可以被不同的线程同时访问，因此在多线程环境下可以提高并发性能，只有当多个线程同时访问同一个 `Segment` 时，才会发生锁竞争。
    
*   性能：**hashmap** 由于没有锁的开销，在单线程环境下性能较好。但在多线程环境下，为了保证线程安全，需要额外的同步机制，这会降低性能。`ConcurrentHashMap`通过分段锁机制，在多线程环境下可以实现更高的并发性能，不同的线程可以同时访问不同的 `Segment`，从而减少了锁竞争的可能性。
    

> JDK1.8 版本：hashmap 和 concurrenthashmap 的区别

*   内存结构：**hashmap** 采用数组 + 链表 + 红黑树的结构，当链表长度超过一定阈值（默认为 8）时，链表会转换为红黑树，以提高查找效率。`ConcurrentHashMap`弃了分段锁机制，采用 CAS + `synchronized` 来保证线程安全，内部结构同样是数组 + 链表 + 红黑树。
    
*   线程安全性：**hashmap** 仍然是非线程安全的，多线程环境下的问题依然存在。`ConcurrentHashMap`通过 CAS 和 `synchronized` 保证线程安全。在插入元素时，首先会尝试使用 CAS 操作更新节点，如果 CAS 失败，则使用 `synchronized` 锁住当前节点，再进行插入操作。
    
*   性能：**hashmap** 在单线程环境下，由于红黑树的引入，当链表较长时查找效率会有所提高。`ConcurrentHashMap`在多线程环境下，由于摒弃了分段锁，减少了锁的粒度，进一步提高了并发性能。同时，红黑树的引入也提高了查找效率。
    

TPLink 联洲（C++ 嵌入式一面）
--------------------

### 1. 堆和栈的区别是什么？

*   **内存的分配和释放**：**栈内存**的分配和释放由系统自动处理，在函数调用时，函数的局部变量、参数等会被压入栈中；函数执行结束，这些变量所占内存会自动释放。**堆内存**需要手动进行内存的分配和释放，使用`new`操作符来分配内存，使用`delete`操作符释放内存；若使用`malloc`函数分配内存，就用`free`函数释放。要是忘记释放堆上的内存，会造成内存泄漏。
    
*   **内存分配效率**：**栈**于是系统自动管理，栈的内存分配和释放速度较快。它只是简单地移动栈指针，开销很小。**堆**的内存分配和释放相对较慢，因为操作系统需要在堆中寻找合适大小的空闲内存块，并且要处理内存碎片等问题。
    
*   **数据访问效率**：**栈**上的数据访问速度较快，因为栈指针的移动是连续的，数据通常在高速缓存中，能快速访问。**堆**上的数据访问速度相对较慢，因为堆中的内存分配是不连续的，可能会导致缓存不命中，增加访问时间。
    
*   **数据存储的方式**：**栈**上的数据是按照后进先出（LIFO）的顺序存储的。新的数据会被压入栈顶，释放时从栈顶开始依次释放。**堆**上的数据存储没有特定的顺序。内存分配是动态的，操作系统会根据当前堆的使用情况来分配内存。
    

下面是一个简单的 C++ 代码示例，展示了栈和堆的使用：

```
#include <iostream>  
  
int main() {  
    // 栈上分配内存  
    int stackVariable = 10;  
    std::cout << "Stack variable: " << stackVariable << std::endl;  
  
    // 堆上分配内存  
    int* heapVariable = newint(20);  
    std::cout << "Heap variable: " << *heapVariable << std::endl;  
  
    // 释放堆上的内存  
    delete heapVariable;  
  
    return0;  
}  

```

### 2. c++ 三大特性介绍一下？

c++ 的三大特性，说白了其实就是面向对象的三大特性，是指：封装、继承、多态，简单说明如下：

*   封装是一种技术，它使类的定义和实现分离，也就是隐藏了实现细节，只留下接口给他人调用，另外封装还有一层意义是它把某种事物具现出属性和方法并形成了一个整体，就像一个人，同时具有身高和身体等等这些，才是完整的人，如果不封装，那这个人就相当于四分五裂了；
    
*   继承，所谓继承，其实就是真实意义上讲的继承了某些东西，放到 c++ 的类里面，其实就是实现了代码的重用，即派生类要使用基类的属性和方法，就不用再重新编写代码，这种可以算是实现继承。还有一种就是继承了某样东西，但是派生类需要重新实现一下，也就是接口继承，下面第三点要讲的多态就是接口继承的典型代表；
    
*   多态，多种形态，就是我们使用基类的指针或者引用调用基类的某个函数时，编译期并不知道到底是要调用哪个函数，因为我们不能确定这个指针或者引用到底指向基类对象还是派生类对象，直到运行时才能确定，这个就叫多态。
    

### 3. 进程间通信方式是什么？

Linux 内核提供了不少进程间通信的方式：

*   管道：管道是一种单向的通信机制，允许一个进程的输出作为另一个进程的输入。管道分为「匿名管道」和「命名管道」。
    

*   **匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向**的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
    
*   **命名管道**突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核**中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。
    

*   消息队列：**消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**
    
*   共享内存：**共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问**，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，多进程竞争同个共享资源会造成数据的错乱。**
    
*   信号：与信号量名字很相似的叫**信号**，它俩名字虽然相似，但功能一点儿都不一样。信号是**异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SIGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。
    
*   信号量：**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。
    
*   socket：前面说到的通信机制，都是工作于同一台主机，如果**要与不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。
    

### 4. tcp 和 udp 区别说一下？

*   连接：TCP 是面向连接的传输层协议，传输数据前先要建立连接；UDP 是不需要连接，即刻传输数据。
    
*   服务对象：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信
    
*   可靠性：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议
    
*   拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
    
*   首部开销：TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
    
*   传输方式：TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
    

### 5. 引用和指针的区别是什么？

**指针和引用主要有以下区别：**

*   引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
    
*   引用初始化后不能被改变，指针可以改变所指的对象。
    
*   不存在指向空值的引用，但是存在指向空值的指针。
    

从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。

除此之外还有如下区别：

*   指针是一个实体，而引用仅是个别名；
    
*   引用只能在定义时被初始化一次，之后不可变；指针可变；引用 “从一而终”，指针可以 “见异思迁”；
    
*   引用没有 const，指针有 const，const 的指针不可变；
    
*   引用不能为空，指针可以为空；
    
*   “sizeof 引用”得到的是所指向的变量 (对象) 的大小，而 “sizeof 指针” 得到的是指针本身的大小；
    
*   指针和引用的自增 (++) 运算意义不一样；
    
*   引用是类型安全的，而指针不是 (引用比指针多了类型检查）
    

传参区别：

```
#include <iostream>  
usingnamespacestd;  
  
void foo(int* ptr) {//指针  
    *ptr = 42;  
    cout<<"*ptr = "<<*ptr<<endl;//42  
}  
  
void foo1(int& ref) {//引用  
    ref = 5;  
    cout<<"ref = "<<ref<<endl;//5  
}  
  
int main() {  
    int x = 10;  
    int* ptr = &x;  
      
    foo1(x);  
    foo(ptr);  
      
    cout<<"x = "<<x<<endl;  
    return0;  
}  

```

  

推荐阅读：

[后端训练营，又开卷了！！](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247546260&idx=2&sn=7505a8cd6e0156744f2c47a06ff54ec2&scene=21#wechat_redirect)

[小红书取消大小周，有人不高兴了。。](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247547965&idx=1&sn=cc5059b2c4a114a8a826f1e6a0d993e2&scene=21#wechat_redirect)

[货拉拉成功进入二面！！](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247547919&idx=1&sn=aaef464a349f25af758d752138f87593&scene=21#wechat_redirect)